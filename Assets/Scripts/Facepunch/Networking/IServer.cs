using ProtoBuf;
using System;
using System.Collections.Generic;
using System.Net;
using System.Reflection;
using System.Threading;
using UnityEngine;

namespace Facepunch.Networking
{
    public delegate void MessageHandler<in TMessage>(IRemote sender, TMessage message)
        where TMessage : INetworkMessage;

    public delegate void MessageHandler(IRemote sender, INetworkMessage message);

    public delegate void ClientConnectEventHandler(IRemote client);

    public delegate void ClientDisconnectEventHandler(IRemote client, string reason);

    public interface IServer : IDisposable
    {
        /// <summary>
        /// Networking system status.
        /// </summary>
        NetStatus NetStatus { get; }

        /// <summary>
        /// Networking thread for this peer.
        /// </summary>
        Thread NetThread { get; }

        /// <summary>
        /// Event for log messages generated by the server.
        /// </summary>
        event UnityEngine.Application.LogCallback LogMessage;

        void Log(LogType type, String format, params object[] args);

        void PopulateMessageTable(Assembly asm);

        /// <summary>
        /// Handle any queued incoming messages. Returns true if any
        /// messages were received, otherwise false.
        /// </summary>
        bool CheckForMessages();

        /// <summary>
        /// Send any queued messages.
        /// </summary>
        void FlushSentMessages();

        /// <summary>
        /// Close connections and stop listening.
        /// </summary>
        void Shutdown();

        event EventHandler ShuttingDown;

        /// <summary>
        /// Registers a delegate for handling messages of a given type.
        /// </summary>
        void RegisterHandler<TMessage>(MessageHandler<TMessage> handler)
            where TMessage : INetworkMessage;
    }

    /// <summary>
    /// Interface for locally created listening servers.
    /// </summary>
    public interface ILocalServer : IServer
    {
        /// <summary>
        /// Collection of currently connected clients.
        /// </summary>
        IEnumerable<IRemote> Clients { get; }

        MessageTableSchema GetMessageTableSchema();

        event ClientConnectEventHandler ClientConnected;

        event ClientDisconnectEventHandler ClientDisconnected;

        /// <summary>
        /// Sends a message to the given recipient.
        /// </summary>
        void SendMessage(INetworkMessage message, IRemote recipient, DeliveryMethod method, int sequenceChannel);

        /// <summary>
        /// Sends a message to a collection of recipients.
        /// </summary>
        void SendMessage(INetworkMessage message, IEnumerable<IRemote> recipients, DeliveryMethod method, int sequenceChannel);
    }

    /// <summary>
    /// Interface for remote connections to servers.
    /// </summary>
    public interface IRemoteServer : IServer, IRemote
    {
        void LoadMessageTableFromSchema(MessageTableSchema schema);

        /// <summary>
        /// Sends a message to the server.
        /// </summary>
        void SendMessage(INetworkMessage message, DeliveryMethod method, int sequenceChannel);
    }

    public abstract class ServerBase : IServer
    {
        private readonly MessageTable<INetworkMessage> _messageTable;
        private readonly MessageHandlerCollection<INetworkMessage> _messageHandlers;

        private readonly bool _generateFullMessageTable;

        public abstract NetStatus NetStatus { get; }

        public abstract Thread NetThread { get; }

        public MessageTable<INetworkMessage> MessageTable { get { return _messageTable; } }

        public event UnityEngine.Application.LogCallback LogMessage;

        public event EventHandler ShuttingDown;

        protected ServerBase(bool generateFullMessageTable)
        {
            _messageTable = MessageTable<INetworkMessage>.CreateEmpty();
            _generateFullMessageTable = generateFullMessageTable;

            _messageHandlers = new MessageHandlerCollection<INetworkMessage>();
        }

        public void PopulateMessageTable(Assembly asm)
        {
            _messageTable.Generate(new[] { asm }, !_generateFullMessageTable);
        }

        public void Log(LogType type, String format, params object[] args)
        {
            if (LogMessage == null) return;
            LogMessage(args.Length == 0 ? format : String.Format(format, args),
                //new StackTrace().ToString(),
                String.Empty,
                type);
        }

        public abstract bool CheckForMessages();

        internal void HandleMessage(IRemote sender, INetworkMessage message)
        {
            if (message == null) return;

            _messageHandlers.Handle(sender, message);
            OnHandleMessage(sender, message);
        }

        protected virtual void OnHandleMessage(IRemote sender, INetworkMessage message)
        {
        }

        public abstract void FlushSentMessages();

        public void Shutdown()
        {
            if (ShuttingDown != null) ShuttingDown(this, new EventArgs());

            OnShutdown();
        }

        public void RegisterHandler<TMessage>(MessageHandler<TMessage> handler)
            where TMessage : INetworkMessage
        {
            _messageHandlers.Add(handler);
        }

        protected virtual void OnShutdown()
        {
        }

        public void Dispose()
        {
            OnDispose();
        }

        protected virtual void OnDispose()
        {
            Shutdown();
        }
    }

    public abstract class LocalServer : ServerBase, ILocalServer
    {
        public abstract IEnumerable<IRemote> Clients { get; }

        public event ClientConnectEventHandler ClientConnected;

        public event ClientDisconnectEventHandler ClientDisconnected;

        protected void ClientConnect(IRemote client)
        {
            if (ClientConnected != null) ClientConnected(client);
            OnClientConnected(client);
        }

        protected virtual void OnClientConnected(IRemote client)
        {
        }

        protected void ClientDisconnect(IRemote client, string message)
        {
            if (ClientDisconnected != null) ClientDisconnected(client, message);
            OnClientDisconnected(client, message);
        }

        protected virtual void OnClientDisconnected(IRemote client, string message)
        {
        }

        protected LocalServer() : base(true)
        {
        }

        public MessageTableSchema GetMessageTableSchema()
        {
            return MessageTable.GetSchema();
        }

        public abstract void SendMessage(INetworkMessage message, IRemote recipient, DeliveryMethod method, int sequenceChannel);

        public abstract void SendMessage(INetworkMessage message, IEnumerable<IRemote> recipients, DeliveryMethod method, int sequenceChannel);

        protected override void OnShutdown()
        {
            foreach (var client in Clients)
            {
                client.Disconnect("Server shutting down");
            }
        }
    }

    public abstract class RemoteServer : ServerBase, IRemoteServer
    {
        public abstract IPEndPoint RemoteEndPoint { get; }

        public abstract ConnectionStatus ConnectionStatus { get; }

        public abstract float AverageRoundTripTime { get; }

        public abstract void Disconnect(string message);

        public event ClientDisconnectEventHandler Disconnected;

        protected RemoteServer() : base(false)
        {
        }

        public void LoadMessageTableFromSchema(MessageTableSchema schema)
        {
            MessageTable.FromSchema(schema);
        }

        public abstract void SendMessage(INetworkMessage message, DeliveryMethod method, int sequenceChannel);

        protected void OnDisconnect(string message)
        {
            if (Disconnected != null)
            {
                Disconnected(this, message);
            }
        }
    }
}